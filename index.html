<!DOCTYPE html>
<head>
    <meta charset="utf-8">
    <script src="lib/d3.v7.js"></script>

    <!-- Stylesheet -->
	<style>
		body { text-align: center; }
	</style>
</head>
<canvas></canvas>
<script type="module">
    // import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";

    d3.json("./out/graph.json").then(handleDraw).catch(console.error);

    const MARGIN_VALUE = 30;

    function handleDraw(data) {
        let width = window.innerWidth - MARGIN_VALUE;
        let height = window.innerHeight - MARGIN_VALUE;

        function handleResize() {
            width = window.innerWidth - MARGIN_VALUE;
            height = window.innerHeight - MARGIN_VALUE;
            canvas.attr("width", width).attr("height", height);
        }

        window.addEventListener('resize', handleResize);


        // Specify the color scale.
        const color = d3.scaleOrdinal(d3.schemeCategory10);

        // The force simulation mutates links and nodes, so create a copy
        // so that re-evaluating this cell produces the same result.
        const links = data.links.map(d => ({...d}));
        const nodes = data.nodes.map(d => ({...d}));

        nodes.forEach(node => {node.x = width; node.y = height})

        // Create a simulation with several forces.
        const simulation = d3.forceSimulation(nodes)
            .force("link", d3.forceLink(links).id(d => d.id).distance(20))
            .force("charge", d3.forceManyBody().strength(-6))
            .force("x", d3.forceX(width / 2))
            .force("y", d3.forceY(height / 2))
            .on("tick", draw);

        const canvas = d3.select("canvas")
            .attr("width", width)
            .attr("height", height)
            .on("mousemove", handleMouseMove);

        const context = canvas.node().getContext("2d");

        let currentNodeToLabel = null;
        function drawLabel(node) {
            if (node.id === currentNodeToLabel?.id) {
                context.font = "14px bold-serif";
                context.fillStyle = "black"; // Set text color
                context.textAlign = "center"; // Align text horizontally (e.g., "start", "end", "center")
                context.textBaseline = "middle";
                context.fillText(node.id, node.x-5, node.y-10);
                context.fillStyle = d3.color("yellow");
                context.fill();
            }
        }
        
        function draw() {
            context.clearRect(0, 0, width, height);

            context.save();
            context.globalAlpha = 0.6;
            context.strokeStyle = "#999";
            context.beginPath();
            links.forEach(drawLink);
            context.stroke();
            context.restore();

            context.save();
            context.strokeStyle = "#fff";
            context.globalAlpha = 1;
            nodes.forEach(node => {
                context.beginPath();
                drawNode(node);
                context.fillStyle = color(node.group);
                context.strokeStyle = "#fff";
                context.fill();
                context.stroke();
                context.restore();
                drawLabel(node);
            });
            context.restore();
        }

        function drawLink(d) {
            context.moveTo(d.source.x, d.source.y);
            context.lineTo(d.target.x, d.target.y);
        }

        function drawNode(d) {
            context.moveTo(d.x + 5, d.y);
            context.arc(d.x, d.y, 5, 0, 2 * Math.PI);
        }


        // Add a drag behavior. The _subject_ identifies the closest node to the pointer,
        // conditional on the distance being less than 20 pixels.
        d3.select(canvas).node()
            .call(
                d3.drag()
                .subject(findClosestNodeToTarget)
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended));

        function findClosestNodeToTarget(event) {
            const [px, py] = d3.pointer(event, canvas);
            
            let closestNode = null;
            let minDistance = Infinity;
    
            nodes.forEach(node => {
                const distanceSquared = Math.pow(px - node.x, 2) + 
                                        Math.pow(py - node.y, 2);
                if (distanceSquared < minDistance) {
                    minDistance = distanceSquared;
                    closestNode = node;
                }
            });
            if (closestNode.id !== currentNodeToLabel?.id) {
                currentNodeToLabel = closestNode;
            }
            return closestNode;
        }

        function isOnTopOfNode(pointerCoords, node) {
            const [px, py] = pointerCoords;
            
            const distanceSquared = Math.pow(px - node.x, 2) + 
                                        Math.pow(py - node.y, 2);
            return distanceSquared < 10;
        }

        function handleMouseMove(event) {
            nodes.forEach(node => {
                if (isOnTopOfNode([event.x, event.y], node)) {
                    currentNodeToLabel = node;
                    simulation.restart();
                }
             });
        }

        // Reheat the simulation when drag starts, and fix the subject position.
        function dragstarted(event) {
            if (!event.active) simulation.alphaTarget(0.7).restart();
            event.subject.fx = event.subject.x;
            event.subject.fy = event.subject.y;
        }

        // Update the subject (dragged node) position during drag.
        function dragged(event) {
            event.subject.fx = event.x;
            event.subject.fy = event.y;
        }

        // Restore the target alpha so the simulation cools after dragging ends.
        // Unfix the subject position now that itâ€™s no longer being dragged.
        function dragended(event) {
            if (!event.active) simulation.alphaTarget(0);
            event.subject.fx = event.x;
            event.subject.fy = event.y;
        }
    }

</script>