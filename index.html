<!DOCTYPE html>
<head>
    <meta charset="utf-8">
    <script src="lib/d3.v7.js"></script>

    <!-- Stylesheet -->
	<style>
		body { text-align: center; }
	</style>
</head>
<canvas width=100% height=100%></canvas>
<script type="module">
    // import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";

    d3.json("./out/graph.json").then(handleDraw).catch(console.error);

    function handleDraw(data) {
        const width = 1400;
        const height = 1050;

        // Specify the color scale.
        const color = d3.scaleOrdinal(d3.schemeCategory10);

        // The force simulation mutates links and nodes, so create a copy
        // so that re-evaluating this cell produces the same result.
        const links = data.links.map(d => ({...d}));
        const nodes = data.nodes.map(d => ({...d}));

        nodes.forEach(node => {node.x = width / 2; node.y = height / 2})

        // Create a simulation with several forces.
        const simulation = d3.forceSimulation(nodes)
            .force("link", d3.forceLink(links).id(d => d.id).distance(20))
            .force("charge", d3.forceManyBody().strength(-7))
            .force("x", d3.forceX(width / 2))
            .force("y", d3.forceY(height / 2))
            .on("tick", draw);

        const canvas = d3.select("canvas")
            .attr("width", width)
            .attr("height", height);

        const context = canvas.node().getContext("2d");

        function draw() {
            context.clearRect(0, 0, width, height);

            context.save();
            context.globalAlpha = 0.6;
            context.strokeStyle = "#999";
            context.beginPath();
            links.forEach(drawLink);
            context.stroke();
            context.restore();

            context.save();
            context.strokeStyle = "#fff";
            context.globalAlpha = 1;
            nodes.forEach(node => {
                context.beginPath();
                drawNode(node);
                context.fillStyle = color(node.group);
                context.strokeStyle = "#fff";
                context.fill();
                context.stroke();
            });
            context.restore();
        }

        function drawLink(d) {
            context.moveTo(d.source.x, d.source.y);
            context.lineTo(d.target.x, d.target.y);
        }

        function drawNode(d) {
            context.moveTo(d.x + 5, d.y);
            context.arc(d.x, d.y, 5, 0, 2 * Math.PI);
        }


        // Add a drag behavior. The _subject_ identifies the closest node to the pointer,
        // conditional on the distance being less than 20 pixels.
        d3.select(canvas)
            .call(
                d3.drag()
                .subject(event => {
                const [px, py] = d3.pointer(event, canvas);
                return d3.least(nodes, ({x, y}) => {
                    const dist2 = (x - px) ** 2 + (y - py) ** 2;
                    if (dist2 < 400) return dist2;
                });
                })
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended));

        // Reheat the simulation when drag starts, and fix the subject position.
        function dragstarted(event) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            event.subject.fx = event.subject.x;
            event.subject.fy = event.subject.y;
        }

        // Update the subject (dragged node) position during drag.
        function dragged(event) {
            event.subject.fx = event.x;
            event.subject.fy = event.y;
        }

        // Restore the target alpha so the simulation cools after dragging ends.
        // Unfix the subject position now that itâ€™s no longer being dragged.
        function dragended(event) {
            if (!event.active) simulation.alphaTarget(0);
            event.subject.fx = null;
            event.subject.fy = null;
        }
    }

</script>